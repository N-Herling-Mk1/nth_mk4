<!-- File: index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Audio Visualizer UI</title>

  <!-- Bootstrap (CDN) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>

  <!-- Social Media Preview Tags -->
  <meta property="og:title" content="Audio Visualizer UI" />
  <meta property="og:description" content="Interactive audio visualizer and project showcase." />
  <meta property="og:image" content="assets/images/NTH_6.png" />
  <meta property="og:url" content="_stub_" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Audio Visualizer UI" />
  <meta name="twitter:description" content="Interactive audio visualizer and project showcase." />
  <meta name="twitter:image" content="assets/images/NTH_6.png" />

  <!-- All custom CSS consolidated (no 'pulse') -->
  <style>
    /* Base layout */
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      user-select: none;
      font-family: Arial, sans-serif;
    }

    /* Background traces canvas sits behind all content */
    #grid-canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;            /* behind content but above root bg */
      pointer-events: none;  /* donâ€™t block clicks */
      display: block;
    }

    /* Splash container above background canvas */
    .splash-container {
      position: relative;    /* stacking context above bg canvas */
      z-index: 1;
      min-height: 100vh;
      gap: 1rem;
    }

    /* Heading */
    h2 {
      font-weight: 700;
      margin-bottom: 1rem;
      font-size: 2rem;
    }
    @media (max-width: 576px) {
      h2 { font-size: 1.6rem; }
    }

    /* Image wrapper + image */
    .image-wrapper {
      position: relative;
      max-width: 400px;
      width: 100%;
      margin-bottom: 0.5rem;
      overflow: visible;
    }
    .image-wrapper img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 16px;
      box-shadow: 0 0 15px 5px rgba(0, 120, 255, 0.5);
      transition: filter 0.5s ease, opacity 1s ease;
      cursor: pointer;
    }

    /* Optional fallback button */
    #enter-button {
      padding: 1.2rem 3rem;
      font-size: 1.25rem;
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.05em;
      box-shadow: 0 0 10px #0078ff;
      transition: background-color 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
    }
    #enter-button:disabled {
      background-color: #004fbb !important;
      cursor: default;
      box-shadow: none;
      opacity: 0.6;
    }
    #enter-button:hover:not(:disabled) {
      background-color: #005fcc !important;
      transform: scale(1.05);
      box-shadow: 0 0 25px 5px #0078ff;
    }

    /* Fullscreen black fade overlay */
    #fade-to-black {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
      z-index: 1000;
    }

    /* Visualizer canvas wrapper (over image during playback) */
    #canvas-wrapper {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 15;
    }
    #viz-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    /* Ensure hero image is visible initially */
    #main-image {
      position: relative;
      z-index: 10;
      filter: none; /* no brightness change until click */
    }
  </style>
</head>
<body>
  <!-- Background traces canvas -->
  <canvas id="grid-canvas" aria-hidden="true"></canvas>

  <!-- Splash content -->
  <div class="container splash-container d-flex flex-column align-items-center justify-content-center min-vh-100 text-center px-3">
    <h2 class="mb-2 fw-bold">Welcome to Nathan Herling's personal website.</h2>
    <span class="mb-3">[Press image to enter]</span>

    <div class="image-wrapper mb-4 w-100" style="max-width: 400px;">
      <!-- Clickable Image -->
      <img
        src="assets/images/NTH_7.png"
        alt="Nathan Herling"
        id="main-image"
        class="img-fluid rounded shadow"
      />

      <!-- Visualizer Canvas Wrapper -->
      <div id="canvas-wrapper">
        <canvas id="viz-canvas"></canvas>
      </div>
    </div>

    <!-- Hidden Button (Optional Fallback) -->
    <button id="enter-button" class="btn btn-primary btn-lg px-4 shadow" style="display: none;">
      ENTER HERE
    </button>
  </div>

  <div id="fade-to-black"></div>

  <!-- Optional fallback audio element -->
  <audio id="audio-fallback" preload="auto" playsinline style="display:none;">
    <source src="assets/audio/01_Welcome.mp3" type="audio/mp3" />
  </audio>

  <!-- Splash â†’ audio/visualizer â†’ fade â†’ main.html -->
  <script type="module">
    import { startVisualizer, setAnalyserNode } from './js/visualizer.js';

    const mainImage    = document.getElementById('main-image');
    const canvasWrap   = document.getElementById('canvas-wrapper');
    const vizCanvas    = document.getElementById('viz-canvas');
    const fadeOverlay  = document.getElementById('fade-to-black');

    let audioCtx;
    let analyser;

    function resizeCanvas() {
      vizCanvas.width  = canvasWrap.clientWidth;
      vizCanvas.height = canvasWrap.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    mainImage.addEventListener('click', async () => {
      mainImage.style.pointerEvents = 'none';

      // Fade image to black
      mainImage.style.filter = 'brightness(0)';

      // Short pause
      await new Promise(r => setTimeout(r, 500));

      // Reveal visualizer
      canvasWrap.style.opacity = '1';

      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') await audioCtx.resume();

        const response     = await fetch('assets/audio/01_Welcome.mp3');
        const arrayBuffer  = await response.arrayBuffer();
        const audioBuffer  = await audioCtx.decodeAudioData(arrayBuffer);

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        setAnalyserNode(analyser);

        // Start
        source.start();
        startVisualizer();

        source.onended = async () => {
          await new Promise(r => setTimeout(r, 500));
          fadeOverlay.style.pointerEvents = 'auto';
          fadeOverlay.style.opacity = '1';
          canvasWrap.style.opacity = '0';

          setTimeout(() => {
            window.location.href = 'main.html';
          }, 1000);
        };
      } catch (e) {
        console.error('[Audio] Playback failed:', e);
        alert('Failed to play audio.');
        mainImage.style.pointerEvents = 'auto';
        mainImage.style.filter = 'brightness(1)';
        canvasWrap.style.opacity = '0';
        fadeOverlay.style.opacity = '0';
        fadeOverlay.style.pointerEvents = 'none';
      }
    });
  </script>

  <!-- Background traces animation (white / blue / purple, weighted palette) -->
  <script type="module">
    const canvas = document.getElementById("grid-canvas");
    const ctx = canvas.getContext("2d");

    /* ================= DPR-safe sizing ================= */
    let logicalW = 0, logicalH = 0;  // CSS pixel size

    function fitCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      logicalW = window.innerWidth;
      logicalH = window.innerHeight;

      // Buffer size in device pixels
      canvas.width  = Math.floor(logicalW * dpr);
      canvas.height = Math.floor(logicalH * dpr);

      // Draw in CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      buildGrid();
    }

    /* ================= Tunables ================= */
    let GRID_SPACING   = 100;
    let LINE_WIDTH     = 0.8;

    // ðŸŽ¨ Whitesâ€“Bluesâ€“Purples palette (weighted to favor logo-feel)
    const COLORS = [
      { rgb: [240,250,255], weight: 0.06 },   // faint white flash
      { rgb: [180,220,255], weight: 0.14 },   // pale icy blue
      { rgb: [100,180,255], weight: 0.24 },   // bright electric blue
      { rgb: [ 40,130,255], weight: 0.26 },   // core cobalt glow
      { rgb: [ 10, 80,255], weight: 0.20 },   // deep digital blue
      { rgb: [  0, 50,180], weight: 0.10 },   // very dark base blue
    ];

    function pickWeighted(list){
      const total = list.reduce((s,c)=>s+c.weight,0);
      let r = Math.random()*total;
      for (const c of list){ r -= c.weight; if (r <= 0) return c.rgb; }
      return list[list.length-1].rgb;
    }
    function jitter(rgb, amt=8){
      return rgb.map(v => Math.max(0, Math.min(255, v + (Math.random()*2-1)*amt)));
    }

    let STREAK_RATE    = 1.4;             // spawns per second
    let SPEED_MIN_MAX  = [180, 350];
    let LENGTH_MIN_MAX = [180, 400];
    let CORE_ALPHA     = [0.6, 1.0];

    // Glow + trail controls (slightly wider/softer for logo feel)
    let BLOOM_WIDTH = 5.5;   // slightly tighter beam
    let BLOOM_ALPHA = 0.28;  // stronger halo brightness
    let SHADOW_BLUR = 20;    // more intense glow diffusion
    let TRAIL_FADE  = 0.05;

    /* ================ Grid and Tracers ================ */
    let vLines = [], hLines = [];
    function buildGrid() {
      vLines = []; hLines = [];
      for (let x = 0; x <= logicalW; x += GRID_SPACING) vLines.push(x);
      for (let y = 0; y <= logicalH; y += GRID_SPACING) hLines.push(y);
    }
    fitCanvas();
    window.addEventListener("resize", fitCanvas);

    /* ================ Tracers ================ */
    const tracers = [];
    const rand = (a,b)=> a + Math.random()*(b-a);
    const pick = arr => arr[(Math.random()*arr.length)|0];

    function spawnTracer(){
      const isV = Math.random() < 0.5;
      const color = jitter(pickWeighted(COLORS), 8); // pick weighted, lightly jittered

      if (isV && vLines.length){
        const x = pick(vLines);
        const down = Math.random() < 0.5;
        const speed = (down?1:-1)*rand(...SPEED_MIN_MAX);
        const len = rand(...LENGTH_MIN_MAX);
        const head = down ? -len : logicalH + len;
        tracers.push({dir:'v', line:x, head, len, speed, alpha:rand(...CORE_ALPHA), color});
      } else if (!isV && hLines.length){
        const y = pick(hLines);
        const right = Math.random() < 0.5;
        const speed = (right?1:-1)*rand(...SPEED_MIN_MAX);
        const len = rand(...LENGTH_MIN_MAX);
        const head = right ? -len : logicalW + len;
        tracers.push({dir:'h', line:y, head, len, speed, alpha:rand(...CORE_ALPHA), color});
      }
    }

    /* ================ Drawing ================ */
    function tracerGradient(x1,y1,x2,y2,a,color){
      const [r,g,b] = color;
      const gnt = ctx.createLinearGradient(x1,y1,x2,y2);
      gnt.addColorStop(0,  `rgba(${r},${g},${b},0)`);
      gnt.addColorStop(0.4,`rgba(${r},${g},${b},${a*0.7})`);
      gnt.addColorStop(1,  `rgba(${r},${g},${b},${a})`);
      return gnt;
    }

    function drawTracer(t){
      const [r,g,b] = t.color;
      ctx.save();
      ctx.lineCap = "round";
      ctx.globalCompositeOperation = "lighter";

      // Wide faint halo
      ctx.lineWidth   = LINE_WIDTH + BLOOM_WIDTH;
      ctx.strokeStyle = `rgba(${r},${g},${b},${BLOOM_ALPHA})`;
      ctx.shadowColor = `rgba(${r},${g},${b},${BLOOM_ALPHA})`;
      ctx.shadowBlur  = SHADOW_BLUR;

      if (t.dir === 'v'){
        const y1 = t.head - t.len, y2 = t.head;
        ctx.beginPath(); ctx.moveTo(t.line,y1); ctx.lineTo(t.line,y2); ctx.stroke();

        ctx.lineWidth   = LINE_WIDTH + 0.4;
        ctx.shadowBlur  = SHADOW_BLUR*0.5;
        ctx.strokeStyle = tracerGradient(t.line,y1,t.line,y2,t.alpha,t.color);
        ctx.beginPath(); ctx.moveTo(t.line,y1); ctx.lineTo(t.line,y2); ctx.stroke();
      } else {
        const x1 = t.head - t.len, x2 = t.head;
        ctx.beginPath(); ctx.moveTo(x1,t.line); ctx.lineTo(x2,t.line); ctx.stroke();

        ctx.lineWidth   = LINE_WIDTH + 0.4;
        ctx.shadowBlur  = SHADOW_BLUR*0.5;
        ctx.strokeStyle = tracerGradient(x1,t.line,x2,t.line,t.alpha,t.color);
        ctx.beginPath(); ctx.moveTo(x1,t.line); ctx.lineTo(x2,t.line); ctx.stroke();
      }
      ctx.restore();
    }

    /* ================ Loop ================ */
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.05,(now-last)/1000); last=now;

      if (Math.random() < STREAK_RATE*dt) spawnTracer();

      for (let i=tracers.length-1; i>=0; i--){
        const t = tracers[i];
        t.head += t.speed*dt;
        if (t.dir==='v'){
          if (t.speed>0 && t.head - t.len > logicalH + 5) tracers.splice(i,1);
          else if (t.speed<0 && t.head < -5)              tracers.splice(i,1);
        } else {
          if (t.speed>0 && t.head - t.len > logicalW + 5) tracers.splice(i,1);
          else if (t.speed<0 && t.head < -5)              tracers.splice(i,1);
        }
      }

      // Fade the frame for trails (stays black overall)
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = `rgba(0,0,0,${TRAIL_FADE})`;
      ctx.fillRect(0,0,logicalW,logicalH);

      for (const t of tracers) drawTracer(t);

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // Live tweaks
    window.addEventListener("keydown",e=>{
      if(e.key==='['){GRID_SPACING=Math.max(40,GRID_SPACING-10);buildGrid();}
      if(e.key===']'){GRID_SPACING=Math.min(200,GRID_SPACING+10);buildGrid();}
      if(e.key==='-') STREAK_RATE=Math.max(0.2,STREAK_RATE-0.2);
      if(e.key==='=') STREAK_RATE=Math.min(6,STREAK_RATE+0.2);
    });
  </script>
</body>
</html>
